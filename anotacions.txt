d3: main idea, implement a clone of jetpack joyride and add an AI to play it. To simplify it, there is only one state, the game state, no menus, no pause, no "you died" screen, etc.
d4: Pysics and logic, very simple physics. Gravity adds up, which makes the player go down, and force is applied when the player activates the input, moving the player up. Explain how the more gravity the harder to go up, etc
d5: Illusion of movement, to create the illusion of an infinite runner without using infinite resources, we use some camera tricks. The player never moves in the x axis. The ground and obstacles are the ones moving. To create this illusion, we add a ground, a background and some decorations and we move them using a technique called parallax scrolling. To achieve this effect, we use 2 or more layers (2 in our case) and we move them a little bit every frame to create the movement. To achieve the depth needed, the layers move at different speeds.
d6: sprites, in order to create our characters, we used a standard body with its animations along with the faces of our friends, to create custom characters.
d7: The obstacles are electric balls connected by lasers, which have 5 possible angles. The player must dodge these in order to survive. These are randomly generated every game, so that while training the AI we avoid overfitting. We will talk more about this later.
d8: Collision, the easier and most efficient (with a linear cost) to detect collision is called AABB collision, short for Axis Aligned Bounding Box. For this, the objects are surrounded with a rectangle that is aligned to the axis, and simple logic tests if one of the edges of the rectangle is inside the other. This is very efficient, but very inaccurate as we can see in the example.
d9: Mask collision, on the other hand, is very inefficient, but exactly accurate. It takes a mask (which is just an array of the size of the rectangle coding where there are pixels and where are not) and an offset (to align the rectangles) and it checks if any pixels are overlapping. To compensate for this inefficiency, we constantly check for AABB collisions (virtually no cost) and, once we detect a rectangle collision, we confirm its a real collision by using a mask collision.
d10: Joe
d11: Joe
