d3: main idea, implement a clone of jetpack joyride and add an AI to play it. To simplify it, there is only one state, the game state, no menus, no pause, no "you died" screen, etc.
d4: Pysics and logic, very simple physics. Gravity adds up, which makes the player go down, and force is applied when the player activates the input, moving the player up. Explain how the more gravity the harder to go up, etc
d5: Illusion of movement, to create the illusion of an infinite runner without using infinite resources, we use some camera tricks. The player never moves in the x axis. The ground and obstacles are the ones moving. To create this illusion, we add a ground, a background and some decorations and we move them using a technique called parallax scrolling. To achieve this effect, we use 2 or more layers (2 in our case) and we move them a little bit every frame to create the movement. To achieve the depth needed, the layers move at different speeds.
d6: sprites, in order to create our characters, we used a standard body with its animations along with the faces of our friends, to create custom characters.
d7: The obstacles are electric balls connected by lasers, which have 5 possible angles. The player must dodge these in order to survive. These are randomly generated every game, so that while training the AI we avoid overfitting. We will talk more about this later.
d8: Collision, the easier and most efficient (with a linear cost) to detect collision is called AABB collision, short for Axis Aligned Bounding Box. For this, the objects are surrounded with a rectangle that is aligned to the axis, and simple logic tests if one of the edges of the rectangle is inside the other. This is very efficient, but very inaccurate as we can see in the example.
d9: Mask collision, on the other hand, is very inefficient, but exactly accurate. It takes a mask (which is just an array of the size of the rectangle coding where there are pixels and where are not) and an offset (to align the rectangles) and it checks if any pixels are overlapping. To compensate for this inefficiency, we constantly check for AABB collisions (virtually no cost) and, once we detect a rectangle collision, we confirm its a real collision by using a mask collision.
d10: To implement the AI that will play our game, we will use the NEAT algorithm, short for Neuro Evolution of Augmented Topologies. The algorithm combines Neural Networks and Genetic algorithms to solve the problem. We implemented the algorithm by means of the neat-python library.
d11: Neural networks are a type of deep learning and AI that consist in using a group of nodes (known as neurons) and connecting them by means of a weighted directed graph, so that we have input neurons (at least one), hidden neurons (not mandatory) and output neurons (at least one), to mimic the behaviour of the human brain. How do they work? Input is given through the input neurons (human senses), is processed by the network, and an output is given (human reaction). Depending on the weight of the connections, the response to the same input may be different. The objective of a neural network is to perfect to weights of the connecions in order to give better responses to inputs. This is done by "training" the neural network with inputs we know the answer of, testing if the neural network is correct.
d12: The networks in our implementation have these inputs: ... and only one output: activating the jetpack or not. The activation function is tanh, which compresses the value of the response between -1 and 1.
d13: Genetic algorithms are the other part of the NEAT algorithm. They consist in creating a population, trying it, and continuing it only with the strongest individuals, inspired by the survival of the fittest by charles darwin. The first part of this algorithm is the selection. how do we decide which individual is the best? by using a fitness function. The higher the value of the function the best the player. In our game, an individual gains fitness every frame it survives, and also gains a bonus when surpassing a laser. Genetic operators are used to create newer individuals from the fittest of a generation, creating the next one. The operations are mutation (in which an individual modifies an attribute of itself randomly) and crossover/reproduction (in which two individuals combine their configurations to create a new one). Our configuration also implements elitism, so that for every generation, the 2 best individuals are carried on to the next unmodified, to guarantee at least a score as good as the last.
d14: To implement NEAT we took these 3 steps: First, adapting the game so there is not just one player, but multiple. Then, implementing the algorithm itself, defining the fitness function, the initial networks, the configs...Once done, we trained it and tested it with multiple configurations and evaluated the results we found.

